---
title:  "Boostcamp AI tech NLP 과정 1주차 노트"
categories: boostcamp-aitech
tag: [Boostcamp-aitech, NLP, Python]
author_profile: false
sidebar:
    nav: "docs"
search: true
---

## Python

### Decorator

데코레이터(Decorator)는 파이썬에서 함수나 클래스의 기능을 확장하거나 수정할 수 있는 강력한 도구입니다. 데코레이터는 함수나 메서드의 정의 위에 `@decorator`와 같은 형태로 사용됩니다. 여기에 간단한 예시를 통해 데코레이터를 설명하겠습니다.

함수 데코레이터 예시:

```python
# 데코레이터 함수 정의
def my_decorator(func):
    def wrapper():
        print("데코레이터 전에 실행되는 코드")
        func()
        print("데코레이터 후에 실행되는 코드")
    return wrapper

# 함수에 데코레이터 적용
@my_decorator
def say_hello():
    print("안녕하세요!")

# 함수 호출
say_hello()
```

이 예시에서 my_decorator 함수는 다른 함수를 받아서 해당 함수를 감싸는 새로운 함수인 wrapper를 생성합니다. 그리고 이 wrapper 함수 내에서 추가적인 코드를 실행한 후에 원래 함수를 호출합니다.

클래스 데코레이터 예시:

```python
# 클래스 데코레이터 정의
def my_class_decorator(cls):
    class NewClass:
        def __init__(self, *args, **kwargs):
            self.instance = cls(*args, **kwargs)

        def modified_method(self):
            print("클래스 데코레이터에서 추가된 메서드")

    return NewClass

# 클래스에 데코레이터 적용
@my_class_decorator
class MyClass:
    def __init__(self, name):
        self.name = name

    def original_method(self):
        print(f"안녕하세요! {self.name}")

# 클래스 인스턴스 생성
my_instance = MyClass("John")

# 데코레이터에서 추가된 메서드 호출
my_instance.modified_method()

# 원래 클래스 메서드 호출
my_instance.original_method()

```


이 예시에서는 클래스 데코레이터를 사용하여 기존 클래스에 새로운 메서드를 추가했습니다. 데코레이터는 코드를 간결하게 만들고 재사용성을 높여주는데 도움이 됩니다. 그러나 데코레이터를 사용할 때에는 코드의 가독성을 유지하고 어떤 동작을 하는지 명확하게 이해할 수 있도록 주의해야 합니다.

데코레이터의 예시는 Django 에서도 쉽게 찾을수 있습니다. Django에서 데코레이터는 주로 뷰 함수나 클래스 기반 뷰에 적용되어 특정 기능을 추가하거나 특정 조건을 체크하는 데 사용됩니다. 다양한 데코레이터가 내장되어 있으며, 또한 사용자 정의 데코레이터를 만들어서 활용할 수도 있습니다.

1. `@login_required`
`@login_required` 데코레이터는 사용자가 로그인되어 있는지 확인하고, 로그인되어 있지 않으면 로그인 페이지로 리다이렉트합니다.

```python
from django.contrib.auth.decorators import login_required
from django.shortcuts import render

@login_required
def my_view(request):
    # 로그인이 되어 있는 경우에만 이 뷰가 호출됨
    return render(request, 'my_template.html')
```

2. `@user_passes_test`
`@user_passes_test` 데코레이터는 특정 사용자의 조건을 체크하고, 조건을 만족하지 않으면 지정된 페이지로 리다이렉트합니다.

```python
from django.contrib.auth.decorators import user_passes_test
from django.shortcuts import render

def is_staff_user(user):
    return user.is_staff

@user_passes_test(is_staff_user)
def staff_only_view(request):
    # 스태프 권한을 가진 사용자에게만 이 뷰가 호출됨
    return render(request, 'staff_only_template.html')
```

## Math

### 딥러닝의 과정

1. 순전파 (Forward Propagation):

   - 입력 데이터가 네트워크에 주어지고, 각 층에서 가중치와 활성화 함수를 사용하여 출력이 계산됩니다.

   - 출력은 손실 함수(loss function)를 통해 실제 값과 비교되어 에러를 산출합니다.

2. 손실 함수의 미분 계산:

   - 역전파는 먼저 손실 함수를 통해 얻은 에러에 대한 그래디언트(기울기)를 계산합니다.

   - 이 그래디언트는 네트워크의 출력에서부터 시작하여 각 가중치에 대한 손실 함수의 미분 값을 나타냅니다.

3. 역전파 (Backpropagation):

   - 그래디언트를 사용하여 각 가중치를 업데이트합니다. 이는 경사 하강법(Gradient Descent) 또는 그 변형인 최적화 알고리즘을 사용하여 수행됩니다.

   - 역전파는 출력 레이어에서 시작하여 입력 레이어로 거꾸로 진행됩니다.

   - 각 레이어에서는 현재 레이어의 출력과 가중치에 대한 손실 함수의 미분을 이용하여 이전 레이어의 가중치를 업데이트합니다.

4. 가중치 업데이트:

   - 경사 하강법이나 다른 최적화 알고리즘을 사용하여 손실 함수를 최소화하는 방향으로 가중치를 업데이트합니다.

   - 학습률(learning rate)과 같은 하이퍼파라미터를 사용하여 가중치 업데이트의 크기를 조절할 수 있습니다.
